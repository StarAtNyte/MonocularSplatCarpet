<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Splat Carpet - Rug Placement Viewer (Better Floor Detection)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: #000;
        }

        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            width: 280px;
        }

        .btn {
            padding: 10px 16px;
            font-size: 12px;
            font-weight: 500;
            color: #ebebeb;
            background: #1f1f1f;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s ease;
            text-align: left;
        }

        .btn:hover:not(:disabled) {
            background: #2a2a2a;
            border-color: #4a4a4a;
        }

        .btn:active:not(:disabled) {
            background: #252525;
        }

        .btn:disabled {
            background: #181818;
            color: #6e6e6e;
            border-color: #2a2a2a;
            cursor: not-allowed;
        }

        #rugUploadContainer,
        #splatSelectContainer,
        #rugSelectContainer,
        #generateSplatContainer {
            padding: 10px;
            background: #1f1f1f;
            border-radius: 4px;
            border: 1px solid #3a3a3a;
            overflow: hidden;
        }

        #rugUploadContainer label,
        #splatSelectContainer label,
        #rugSelectContainer label,
        #generateSplatContainer label {
            color: #ebebeb;
            font-size: 11px;
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
        }

        #rugImageInput,
        #generateSplatInput {
            font-size: 11px;
            color: #ebebeb;
            width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        #generateSplatBtn {
            margin-top: 8px;
            width: 100%;
        }

        #splatSelect,
        #rugSelect {
            width: 100%;
            padding: 6px 12px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 3px;
            color: #ebebeb;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        #splatSelect:hover,
        #rugSelect:hover {
            background: #333;
            border-color: #4a4a4a;
        }

        #splatSelect:focus,
        #rugSelect:focus {
            outline: none;
            border-color: #5a5a5a;
        }

        #rugImageInput::file-selector-button,
        #generateSplatInput::file-selector-button {
            padding: 6px 12px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 3px;
            color: #ebebeb;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            margin-right: 8px;
            transition: all 0.15s ease;
        }

        #rugImageInput::file-selector-button:hover,
        #generateSplatInput::file-selector-button:hover {
            background: #333;
            border-color: #4a4a4a;
        }

        #status {
            padding: 10px 12px;
            background: #1f1f1f;
            color: #ebebeb;
            border-radius: 4px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 11px;
            line-height: 1.5;
            border: 1px solid #3a3a3a;
            display: none;
            word-wrap: break-word;
        }

        #status.loading {
            animation: pulse 2s ease-in-out infinite;
            border-color: #4a90e2;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
                border-color: #4a90e2;
            }

            50% {
                opacity: 0.8;
                border-color: #6ab0ff;
            }
        }

        #fpsHint {
            padding: 8px 12px;
            background: #1a2a1a;
            color: #90ee90;
            border-radius: 4px;
            font-size: 11px;
            border: 1px solid #2a4a2a;
            text-align: center;
        }

        #instructions {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            padding: 10px 16px;
            background: rgba(31, 31, 31, 0.9);
            color: #ebebeb;
            border-radius: 4px;
            font-size: 12px;
            border: 1px solid #3a3a3a;
            text-align: center;
            backdrop-filter: blur(10px);
        }

        #instructions kbd {
            background: #2a2a2a;
            border: 1px solid #4a4a4a;
            border-radius: 3px;
            padding: 2px 6px;
            font-family: monospace;
            font-size: 11px;
            font-weight: bold;
        }

        .lil-gui {
            --width: 320px;
            --widget-height: 20px;
            --name-width: 22%;
            --number-width: 40px;
            --slider-input-width: 40px;
            --slider-input-min-width: 40px;
        }

        .lil-gui.root {
            width: var(--width);
        }

        .progressBarOuterContainer {
            display: none !important;
        }

        /* Radio button styling */
        .view-type-container {
            margin-top: 8px;
            margin-bottom: 8px;
        }

        .view-type-container>label {
            display: block;
            margin-bottom: 6px;
            color: #ebebeb;
            font-size: 11px;
            font-weight: 500;
        }

        .radio-group {
            display: flex;
            gap: 0;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            padding: 2px;
        }

        .radio-option {
            flex: 1;
            position: relative;
        }

        .radio-option input[type="radio"] {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
        }

        .radio-label {
            display: block;
            padding: 6px 12px;
            text-align: center;
            font-size: 11px;
            font-weight: 500;
            color: #ababab;
            background: transparent;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.15s ease;
            user-select: none;
        }

        .radio-option input[type="radio"]:checked+.radio-label {
            background: #1f1f1f;
            color: #ebebeb;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .radio-label:hover {
            color: #ebebeb;
        }
    </style>
</head>

<body>

    <div id="controls">
        <div id="splatSelectContainer">
            <label>Select Splat Scene:</label>
            <select id="splatSelect">
                <option value="splats/sharp_room1.ply" selected>Sharp Room 1</option>
                <option value="splats/sharp_room2.ply">Sharp Room 2</option>
                <option value="splats/sharp_room3.ply">Sharp Room 3</option>
                <option value="splats/sharp_room4.ply">Sharp Room 4</option>
                <option value="splats/sharp_room5.ply">Sharp Room 5</option>
                <option value="splats/sharp_room6.ply">Sharp Room 6</option>


            </select>
        </div>
        <div id="generateSplatContainer">
            <label>Generate Splat from Image:</label>
            <input type="file" id="generateSplatInput" accept="image/*">

            <div class="view-type-container">
                <label>Camera View Type:</label>
                <div class="radio-group">
                    <div class="radio-option">
                        <input type="radio" name="viewType" value="front" id="viewFront" checked>
                        <label for="viewFront" class="radio-label">Front View</label>
                    </div>
                    <div class="radio-option">
                        <input type="radio" name="viewType" value="top" id="viewTop">
                        <label for="viewTop" class="radio-label">Top View</label>
                    </div>
                </div>
            </div>

            <button class="btn" id="generateSplatBtn" disabled>Generate Splat</button>
            <button class="btn" id="downloadPlyBtn" disabled style="margin-top: 8px;">Download PLY File</button>
        </div>
        <div id="rugSelectContainer">
            <label>Select Sample Rug:</label>
            <select id="rugSelect">
                <option value="" selected>Choose a rug</option>
                <option value="Atlantede.jpg">Atlantede</option>
                <option value="Easther.jpg">Easther</option>
                <option value="Tappeto Classico.jpg">Tappeto Classico</option>
                <option value="Tappeto Classico Sea Green .jpg">Tappeto Classico Sea Green</option>
                <option value="Telerense.jpg">Telerense</option>
            </select>
        </div>
        <div id="rugUploadContainer">
            <label>Upload Custom Rug:</label>
            <input type="file" id="rugImageInput" accept="image/*">
        </div>
        <button class="btn" id="toggleFloorBtn" disabled>Show Floor Detection</button>
        <div id="status"></div>
    </div>

    <div id="instructions">
        Press <kbd>H</kbd> to hide/show controls
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
            "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.2/+esm"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import * as GaussianSplats3D from 'https://cdn.jsdelivr.net/npm/@mkkellogg/gaussian-splats-3d@0.4.7/build/gaussian-splats-3d.module.js';
        import { GUI } from 'lil-gui';

        // No service worker needed - we'll use data URLs directly

        let viewer, rug;
        let detectedPlane = null;
        let floorPlaneMesh = null;
        let floorPlaneVisible = false;
        let gui;
        let customRugTexture = null;
        let splatLoaded = false;
        let currentSplatPath = 'splats/sharp_room1.ply';
        let lastCameraPosition = null; // Track camera position when rug was last placed
        let cameraMovementThreshold = 0.5; // How much camera must move to trigger recalculation

        let raycaster = new THREE.Raycaster();
        let isDragging = false;
        let isRotating = false;
        let isResizing = false;
        let activeCorner = null;
        let offset = new THREE.Vector3();
        let previousMouse = { x: 0, y: 0 };
        let initialScale = 1;
        let initialDistance = 0;
        let oppositeCornerWorld = null;
        let draggedCornerWorld = null;
        let initialRugCenter = null;
        let gizmoRing = null;
        let gizmoHandle = null;
        let cornerHandles = [];
        let gizmoVisible = false;

        // API generated splat data
        let generatedSplatData = null;
        let floorMaskData = null;
        let floorOrientation = 'horizontal'; // 'horizontal' or 'vertical'
        let selectedImageFile = null;


        const rugParams = {
            visible: true,
            offsetX: 0,
            offsetY: 0.0, // Small offset to place rug above the floor visualization grid
            offsetZ: 0,
            rotation: 0,
            scale: 0.5
        };


        /**
         * Call the Sharp API to generate splat from image
         */
        async function generateSplatFromImage(imageFile) {
            const status = document.getElementById('status');
            const generateBtn = document.getElementById('generateSplatBtn');

            status.style.display = 'block';
            status.classList.add('loading');
            status.textContent = 'Uploading image to API...';

            // Disable button and show loading state
            generateBtn.disabled = true;
            generateBtn.textContent = 'Generating...';

            try {
                const formData = new FormData();
                formData.append('file', imageFile);

                const apiUrl = 'https://nitizkhanal00--sharp-api-myroom-v2-fastapi-app.modal.run/predict';

                status.innerHTML = '<strong>Generating splat...</strong><br>This may take 1-2 minutes. Please wait.';

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.statusText}`);
                }

                // Stream and parse JSON incrementally to avoid blocking
                status.innerHTML = '<strong>Processing API response...</strong><br>Receiving data...';

                const reader = response.body.getReader();
                const chunks = [];
                let receivedLength = 0;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    chunks.push(value);
                    receivedLength += value.length;

                    // Update progress
                    const mb = (receivedLength / 1024 / 1024).toFixed(2);
                    status.innerHTML = `<strong>Processing API response...</strong><br>Received ${mb} MB...`;

                    // Yield to UI
                    await new Promise(resolve => setTimeout(resolve, 0));
                }

                // Combine chunks
                status.textContent = 'Parsing response data...';
                const chunksAll = new Uint8Array(receivedLength);
                let position = 0;
                for (let chunk of chunks) {
                    chunksAll.set(chunk, position);
                    position += chunk.length;
                }

                // Decode to string and parse JSON
                const text = new TextDecoder("utf-8").decode(chunksAll);
                const result = JSON.parse(text);

                // Store base64 data (not decoded yet - we'll decode in chunks later)
                generatedSplatData = result.ply;
                floorMaskData = result.floor_mask_3d; // This is a boolean array, not base64

                console.log('Response size:', receivedLength, 'bytes (', (receivedLength / 1024 / 1024).toFixed(2), 'MB)');

                // Log floor mask info
                if (result.floor_mask_3d) {
                    console.log('Floor mask 3D received:', result.floor_mask_3d.length, 'values');
                    console.log('Floor coverage 3D:', (result.floor_coverage_3d * 100).toFixed(1) + '%');
                }
                if (result.gaussian_grid_info) {
                    console.log('Gaussian grid info:', result.gaussian_grid_info);
                }

                // Get user-selected view type
                const viewType = document.querySelector('input[name="viewType"]:checked').value;

                // Set floor orientation based on view type
                // Top view = camera looking down → floor is vertical plane (perpendicular to view)
                // Front view = camera looking forward → floor is horizontal plane (ground)
                floorOrientation = viewType === 'top' ? 'vertical' : 'horizontal';

                console.log('View type:', viewType, '→ Floor orientation:', floorOrientation);
                status.innerHTML = `<strong>View: ${viewType === 'top' ? 'Top' : 'Front'} (${floorOrientation})</strong><br>Loading splat...`;

                // Load the generated splat
                loadGeneratedSplat();

            } catch (error) {
                console.error('Error generating splat:', error);
                status.classList.remove('loading');
                status.innerHTML = `<strong>Error:</strong> ${error.message}`;

                // Re-enable button on error
                generateBtn.disabled = false;
                generateBtn.textContent = 'Generate Splat';
            }
        }

        /**
         * Load the generated splat from API response
         */
        async function loadGeneratedSplat() {
            if (!generatedSplatData) {
                console.error('No generated splat data available');
                return;
            }

            const status = document.getElementById('status');
            const generateBtn = document.getElementById('generateSplatBtn');

            try {
                status.textContent = 'Preparing splat data...';

                // Use data URL approach - embed base64 directly in URL with .ply filename
                // Format: data:application/octet-stream;base64,<data>#filename.ply
                const dataUrl = `data:application/octet-stream;base64,${generatedSplatData}#generated.ply`;

                console.log('Created data URL for PLY data, size:', generatedSplatData.length, 'chars');

                status.textContent = 'Cleaning up old scene...';

                // Clean up old scene
                cleanupScene();

                // Remove old splat
                if (viewer.splatMesh) {
                    await viewer.removeSplatScene(0);
                }

                splatLoaded = false;

                status.textContent = 'Loading new splat scene...';

                console.log('Loading splat from data URL');

                const loadPromise = viewer.addSplatScene(dataUrl, {
                    progressiveLoad: true
                });

                const timeoutPromise = new Promise((_, reject) =>
                    setTimeout(() => reject(new Error('Loading timeout after 30s')), 30000)
                );

                await Promise.race([loadPromise, timeoutPromise]);

                viewer.start();
                splatLoaded = true;

                // Enable floor detection button with appropriate text
                const toggleFloorBtn = document.getElementById('toggleFloorBtn');
                toggleFloorBtn.disabled = false;
                toggleFloorBtn.textContent = (floorMaskData && Array.isArray(floorMaskData)) ? 'Show Floor Plane' : 'Show Floor Detection';

                // Camera controls enabled
                viewer.controls.enabled = true;
                viewer.controls.enableZoom = true;
                viewer.controls.enableRotate = true;
                viewer.controls.enablePan = true;

                status.classList.remove('loading');
                status.innerHTML = '<strong>Splat loaded successfully!</strong><br>Select a rug to place on the detected floor.';

                // Re-enable button
                generateBtn.disabled = false;
                generateBtn.textContent = 'Generate Splat';

                // Enable download button
                document.getElementById('downloadPlyBtn').disabled = false;

            } catch (error) {
                console.error('Error loading generated splat:', error);
                status.classList.remove('loading');
                status.innerHTML = `<strong>Error loading splat:</strong> ${error.message}`;

                // Re-enable button on error
                generateBtn.disabled = false;
                generateBtn.textContent = 'Generate Splat';
            }
        }

        /**
         * Download the generated PLY file
         */
        function downloadGeneratedPLY() {
            if (!generatedSplatData) {
                alert('No PLY data available. Please generate a splat first.');
                return;
            }

            // Decode base64 to binary
            const binaryString = atob(generatedSplatData);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }

            // Create blob and download
            const blob = new Blob([bytes], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'generated_room.ply';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            console.log('PLY file downloaded: generated_room.ply');
        }

        // Detect plane perpendicular to camera (for top-down views)
        function detectTopDownPlane(points, cameraPos, cameraDir, threshold) {
            const count = points.length;

            if (count < 50) {
                console.log('Not enough points for top-down detection');
                return null;
            }

            // For top-down view: plane normal = camera forward direction
            // This ensures the plane is perfectly perpendicular to the camera
            const planeNormal = cameraDir.clone().normalize();

            console.log('Top-down plane normal (camera forward):', planeNormal);

            // Find optimal plane distance by projecting points onto camera forward ray
            const distances = [];
            for (let i = 0; i < count; i++) {
                const p = points[i];
                const toPoint = new THREE.Vector3(p.x - cameraPos.x, p.y - cameraPos.y, p.z - cameraPos.z);
                // Project onto camera forward direction
                const dist = toPoint.dot(planeNormal);
                if (dist > 0.5 && dist < 8.0) { // Reasonable viewing range
                    distances.push(dist);
                }
            }

            if (distances.length < 50) {
                console.log('Not enough points in viewing range');
                return null;
            }

            // Use median distance to avoid outliers
            distances.sort((a, b) => a - b);
            const medianDistance = distances[Math.floor(distances.length / 2)];

            // Create plane at median distance along camera forward ray
            const centroid = cameraPos.clone().add(planeNormal.clone().multiplyScalar(medianDistance));

            // Count inliers at this plane
            const planeDValue = -planeNormal.dot(centroid);
            let inliers = 0;
            for (let i = 0; i < count; i++) {
                const p = points[i];
                const dist = Math.abs(planeNormal.x * p.x + planeNormal.y * p.y + planeNormal.z * p.z + planeDValue);
                if (dist < threshold) inliers++;
            }

            console.log('Top-down plane detected:');
            console.log('  Normal:', planeNormal);
            console.log('  Centroid:', centroid);
            console.log('  Distance from camera:', medianDistance.toFixed(2));
            console.log('  Inliers:', inliers, '/', count);

            return {
                normal: planeNormal,
                d: planeDValue,
                centroid: centroid,
                inliers: inliers,
                adaptiveOffset: 0.0 // Top-down planes don't need offset
            };
        }

        // Detect vertical planes (walls) in front of camera for wall-mounted items
        function detectVerticalPlane(points, iterations, threshold, cameraPos, cameraDir, isInvertedY) {
            const count = points.length;

            // Filter points that are in front of the camera
            const frontPoints = [];
            for (let i = 0; i < count; i++) {
                const p = points[i];
                const toPoint = new THREE.Vector3(p.x - cameraPos.x, p.y - cameraPos.y, p.z - cameraPos.z);

                // Check if point is in front (dot product with camera direction > 0)
                const inFront = toPoint.dot(cameraDir) > 0;

                // Also filter by distance (reasonable viewing range)
                const dist = toPoint.length();
                if (inFront && dist > 0.5 && dist < 8.0) {
                    frontPoints.push({ ...p, dist: dist });
                }
            }

            console.log(`Filtered ${frontPoints.length} points in front of camera (out of ${count})`);

            if (frontPoints.length < 50) {
                console.log('Not enough points in front of camera');
                return null;
            }

            // Sort by distance and focus on closest points (likely the wall in view)
            frontPoints.sort((a, b) => a.dist - b.dist);
            const workingPoints = frontPoints.slice(0, Math.min(10000, frontPoints.length));

            // RANSAC to find best vertical plane
            let bestPlane = null;
            let maxInliers = -1;
            const v1 = { x: 0, y: 0, z: 0 }, v2 = { x: 0, y: 0, z: 0 }, n = { x: 0, y: 0, z: 0 };

            for (let i = 0; i < iterations; i++) {
                // Pick 3 random points
                const p1 = workingPoints[Math.floor(Math.random() * workingPoints.length)];
                const p2 = workingPoints[Math.floor(Math.random() * workingPoints.length)];
                const p3 = workingPoints[Math.floor(Math.random() * workingPoints.length)];

                // Calculate plane normal
                v1.x = p2.x - p1.x; v1.y = p2.y - p1.y; v1.z = p2.z - p1.z;
                v2.x = p3.x - p1.x; v2.y = p3.y - p1.y; v2.z = p3.z - p1.z;

                n.x = v1.y * v2.z - v1.z * v2.y;
                n.y = v1.z * v2.x - v1.x * v2.z;
                n.z = v1.x * v2.y - v1.y * v2.x;

                const len = Math.sqrt(n.x * n.x + n.y * n.y + n.z * n.z);
                if (len === 0) continue;
                n.x /= len; n.y /= len; n.z /= len;

                // Check if plane is vertical (normal should be mostly horizontal)
                // For inverted Y coords, Y is still the vertical axis
                // We want normal.y to be close to 0 (horizontal normal = vertical plane)
                if (Math.abs(n.y) > 0.3) continue; // Skip if not vertical enough

                // Also check that plane faces the camera (normal points back at camera)
                const planeToCamera = new THREE.Vector3(
                    cameraPos.x - p1.x,
                    cameraPos.y - p1.y,
                    cameraPos.z - p1.z
                ).normalize();
                const normalVec = new THREE.Vector3(n.x, n.y, n.z);
                const facesCamera = normalVec.dot(planeToCamera) > 0;

                if (!facesCamera) {
                    // Flip normal to face camera
                    n.x = -n.x; n.y = -n.y; n.z = -n.z;
                }

                const d = -(n.x * p1.x + n.y * p1.y + n.z * p1.z);

                // Count inliers
                let currentInliers = 0;
                for (let j = 0; j < workingPoints.length; j += 2) {
                    const p = workingPoints[j];
                    const dist = Math.abs(n.x * p.x + n.y * p.y + n.z * p.z + d);
                    if (dist < threshold) currentInliers++;
                }

                if (currentInliers > maxInliers) {
                    maxInliers = currentInliers;

                    // Calculate centroid of inlier points
                    let cx = 0, cy = 0, cz = 0, inlierCount = 0;
                    for (let j = 0; j < workingPoints.length; j++) {
                        const p = workingPoints[j];
                        const dist = Math.abs(n.x * p.x + n.y * p.y + n.z * p.z + d);
                        if (dist < threshold) {
                            cx += p.x; cy += p.y; cz += p.z;
                            inlierCount++;
                        }
                    }

                    if (inlierCount > 0) {
                        cx /= inlierCount; cy /= inlierCount; cz /= inlierCount;
                    }

                    bestPlane = {
                        normal: new THREE.Vector3(n.x, n.y, n.z),
                        d: d,
                        centroid: new THREE.Vector3(cx, cy, cz),
                        inliers: currentInliers,
                        adaptiveOffset: 0.0 // Vertical planes don't need offset adjustment
                    };
                }
            }

            if (!bestPlane) {
                console.log('No vertical plane found');
                return null;
            }

            console.log('Vertical plane found:');
            console.log('  Normal:', bestPlane.normal);
            console.log('  Centroid:', bestPlane.centroid);
            console.log('  Inliers:', bestPlane.inliers, '/', workingPoints.length);
            console.log('  Distance from camera:', bestPlane.centroid.distanceTo(cameraPos).toFixed(2));

            return bestPlane;
        }

        function ransacPlaneDetection(points, iterations = 2000, threshold = 0.05, orientation = 'horizontal') {
            const count = points.length;
            if (count < 50) return null;

            // Detect coordinate system
            const cameraUp = viewer.camera.up.clone();
            const isInvertedY = cameraUp.y < 0;
            const cameraY = viewer.camera.position.y;
            const cameraPos = viewer.camera.position.clone();
            const cameraDir = new THREE.Vector3();
            viewer.camera.getWorldDirection(cameraDir);

            console.log('Coordinate system:', isInvertedY ? 'INVERTED (up=-Y)' : 'NORMAL (up=+Y)');
            console.log('Camera Y:', cameraY);
            console.log('Orientation:', orientation);

            // FOR VERTICAL FLOORS: Create plane perpendicular to camera view (top-down)
            if (orientation === 'vertical') {
                console.log('Detecting VERTICAL floor (top-down view - perpendicular to camera)');
                return detectTopDownPlane(points, cameraPos, cameraDir, threshold);
            }

            // ========== NEW: Filter points to only those NEAR the camera ==========
            // This prevents detecting noise/outliers far from the actual room
            const maxDistanceFromCamera = 10.0; // Only consider points within 10 units of camera
            const filteredPoints = [];

            for (let i = 0; i < count; i++) {
                const p = points[i];
                const dx = p.x - cameraPos.x;
                const dy = p.y - cameraPos.y;
                const dz = p.z - cameraPos.z;
                const distSq = dx * dx + dy * dy + dz * dz;

                if (distSq <= maxDistanceFromCamera * maxDistanceFromCamera) {
                    filteredPoints.push(p);
                }
            }

            console.log(`Filtered points: ${filteredPoints.length} / ${count} (within ${maxDistanceFromCamera}m of camera)`);

            if (filteredPoints.length < 50) {
                console.log('Too few points near camera after filtering');
                return null;
            }

            // Use filtered points for all subsequent processing
            const workingPoints = filteredPoints;
            const workingCount = workingPoints.length;
            // ======================================================================

            // 1. Find vertical bounds (using filtered points)
            let minY = Infinity, maxY = -Infinity;
            for (let i = 0; i < workingCount; i++) {
                const y = workingPoints[i].y;
                if (y < minY) minY = y;
                if (y > maxY) maxY = y;
            }
            const range = maxY - minY;

            console.log('Y range (filtered):', { minY: minY.toFixed(2), maxY: maxY.toFixed(2), range: range.toFixed(2) });

            // 2. Define THREE search zones:
            const bottomZone = [];
            const middleZone = [];
            const topZone = [];

            // Bottom 25%, Middle 50%, Top 25%
            const bottomThreshold = minY + (range * 0.25);
            const topThreshold = maxY - (range * 0.25);

            for (let i = 0; i < workingCount; i++) {
                const y = workingPoints[i].y;
                if (y < bottomThreshold) {
                    bottomZone.push(workingPoints[i]);
                } else if (y > topThreshold) {
                    topZone.push(workingPoints[i]);
                } else {
                    middleZone.push(workingPoints[i]);
                }
            }

            console.log('Zone distribution:', {
                bottom: bottomZone.length,
                middle: middleZone.length,
                top: topZone.length
            });

            // Detect scene orientation based on point distribution
            const bottomRatio = bottomZone.length / workingCount;
            const topRatio = topZone.length / workingCount;
            const isInverted = topRatio > 0.15; // If top zone has >15% of points, likely inverted

            // For scenes with sparse extremes, search middle zone for floor
            const searchMiddle = (topZone.length < 100 && bottomZone.length > workingCount * 0.5);

            // 3. Helper to run RANSAC on a specific zone
            function findPlaneInZone(zonePoints) {
                if (zonePoints.length < 10) {
                    return null;
                }

                let bestLocalPlane = null;
                let maxInliers = -1;
                const v1 = { x: 0, y: 0, z: 0 }, v2 = { x: 0, y: 0, z: 0 }, n = { x: 0, y: 0, z: 0 };

                for (let i = 0; i < iterations; i++) {
                    const p1 = zonePoints[Math.floor(Math.random() * zonePoints.length)];
                    const p2 = zonePoints[Math.floor(Math.random() * zonePoints.length)];
                    const p3 = zonePoints[Math.floor(Math.random() * zonePoints.length)];

                    v1.x = p2.x - p1.x; v1.y = p2.y - p1.y; v1.z = p2.z - p1.z;
                    v2.x = p3.x - p1.x; v2.y = p3.y - p1.y; v2.z = p3.z - p1.z;

                    n.x = v1.y * v2.z - v1.z * v2.y;
                    n.y = v1.z * v2.x - v1.x * v2.z;
                    n.z = v1.x * v2.y - v1.y * v2.x;

                    const len = Math.sqrt(n.x * n.x + n.y * n.y + n.z * n.z);
                    if (len === 0) continue;
                    n.x /= len; n.y /= len; n.z /= len;

                    // Relaxed flatness check
                    if (Math.abs(n.y) < 0.7) continue;

                    const d = -(n.x * p1.x + n.y * p1.y + n.z * p1.z);

                    // Check inliers within this zone only
                    let currentInliers = 0;
                    for (let j = 0; j < zonePoints.length; j += 2) {
                        const p = zonePoints[j];
                        const dist = n.x * p.x + n.y * p.y + n.z * p.z + d;
                        if (Math.abs(dist) < threshold) currentInliers++;
                    }

                    if (currentInliers > maxInliers) {
                        maxInliers = currentInliers;
                        bestLocalPlane = {
                            normal: new THREE.Vector3(n.x, n.y, n.z),
                            d: d,
                            centroid: new THREE.Vector3(p1.x, p1.y, p1.z),
                            inliers: currentInliers
                        };
                    }
                }
                return bestLocalPlane;
            }

            const planeBottom = findPlaneInZone(bottomZone);
            const planeMiddle = searchMiddle ? findPlaneInZone(middleZone) : null;
            const planeTop = findPlaneInZone(topZone);

            // 4. SMART DECISION LOGIC with inverted coordinate handling
            let finalPlane = null;

            // Override selection for inverted coordinates
            if (isInvertedY && planeBottom && planeTop) {
                const bottomIsAboveCamera = planeBottom.centroid.y > cameraY;
                const topIsAboveCamera = planeTop.centroid.y > cameraY;

                // ========== NEW: Also check distance from camera ==========
                const bottomDist = planeBottom.centroid.distanceTo(cameraPos);
                const topDist = planeTop.centroid.distanceTo(cameraPos);

                console.log('Inverted coord analysis:');
                console.log('  Bottom plane Y:', planeBottom.centroid.y.toFixed(2), bottomIsAboveCamera ? '(above camera ✓)' : '(below camera ✗)', 'dist:', bottomDist.toFixed(2));
                console.log('  Top plane Y:', planeTop.centroid.y.toFixed(2), topIsAboveCamera ? '(above camera ✓)' : '(below camera ✗)', 'dist:', topDist.toFixed(2));

                // Prefer the plane that is:
                // 1. On the correct side of camera (above for inverted)
                // 2. Closer to the camera (to avoid far noise)
                if (topIsAboveCamera && bottomIsAboveCamera) {
                    // Both above - pick closer one
                    finalPlane = topDist < bottomDist ? planeTop : planeBottom;
                    console.log('Both above camera, selected closer plane');
                } else if (topIsAboveCamera) {
                    finalPlane = planeTop;
                    console.log('Selected TOP plane (correct side for inverted coords)');
                } else if (bottomIsAboveCamera) {
                    finalPlane = planeBottom;
                    console.log('Selected BOTTOM plane (correct side for inverted coords)');
                } else {
                    // Neither above camera (shouldn't happen with filtering, but fallback)
                    finalPlane = topDist < bottomDist ? planeTop : planeBottom;
                    console.log('WARNING: Neither plane above camera, using closer one');
                }
                // ===========================================================
            }
            // Original logic for non-inverted or when override doesn't apply
            else if (planeMiddle) {
                finalPlane = planeMiddle;
            } else if (planeTop && planeBottom) {
                if (isInverted) {
                    finalPlane = planeTop;
                } else {
                    finalPlane = planeBottom;
                }
            } else if (planeTop) {
                finalPlane = planeTop;
            } else if (planeBottom) {
                finalPlane = planeBottom;
            }

            if (!finalPlane) return null;

            // ========== NEW: Validate plane is reasonably close to camera ==========
            const planeDist = finalPlane.centroid.distanceTo(cameraPos);
            console.log('Selected plane distance from camera:', planeDist.toFixed(2));

            // More lenient threshold for generated splats which may have noise/artifacts
            const distanceThreshold = 15.0; // Increased from 8.0 to handle noisy splats

            if (planeDist > distanceThreshold) {
                console.warn('WARNING: Detected floor is very far from camera (', planeDist.toFixed(2), 'm)');
                console.warn('This might be noise/artifacts. The floor detection may be inaccurate.');
            }
            // =======================================================================

            // Ensure normal points correctly
            const sceneCenterY = (minY + maxY) / 2;
            if (finalPlane.centroid.y > sceneCenterY) {
                if (finalPlane.normal.y > 0) {
                    finalPlane.normal.negate();
                    finalPlane.d = -finalPlane.d;
                }
            } else {
                if (finalPlane.normal.y < 0) {
                    finalPlane.normal.negate();
                    finalPlane.d = -finalPlane.d;
                }
            }

            // ADAPTIVE OFFSET CALCULATION (using filtered points)
            const floorPlane = new THREE.Plane().setFromNormalAndCoplanarPoint(
                finalPlane.normal,
                finalPlane.centroid
            );

            const nearFloorDistances = [];
            for (let i = 0; i < Math.min(workingPoints.length, 5000); i++) {
                const p = workingPoints[i];
                const pointVec = new THREE.Vector3(p.x, p.y, p.z);
                const distance = floorPlane.distanceToPoint(pointVec);

                if (Math.abs(distance) < 0.2) {
                    nearFloorDistances.push(distance);
                }
            }

            // if (nearFloorDistances.length > 50) {
            //     const abovePlane = nearFloorDistances.filter(d => d > 0).sort((a, b) => a - b);

            //     if (abovePlane.length > 10) {
            //         const percentile75Index = Math.floor(abovePlane.length * 0.75);
            //         const adaptiveOffset = abovePlane[percentile75Index];
            //         finalPlane.adaptiveOffset = Math.max(0.02, Math.min(0.10, adaptiveOffset));
            //         console.log(`Adaptive offset calculated: ${finalPlane.adaptiveOffset.toFixed(3)}m (from ${abovePlane.length} points)`);
            //     } else {
            //         finalPlane.adaptiveOffset = 0.035;
            //         console.log('Using default offset: insufficient data for adaptive calculation');
            //     }
            // } else {
            //     finalPlane.adaptiveOffset = 0.035;
            //     console.log('Using default offset: insufficient near-floor points');
            // }

            return finalPlane;
        }

        function createRug(textureUrl) {
            return new Promise((resolve, reject) => {
                const textureLoader = new THREE.TextureLoader();
                textureLoader.load(textureUrl, (texture) => {
                    if (rug && viewer.threeScene) {
                        viewer.threeScene.remove(rug);
                        rug.geometry.dispose();
                        rug.material.dispose();
                    }

                    // Cleanup old gizmo
                    if (gizmoRing) {
                        gizmoRing.geometry.dispose();
                        gizmoRing.material.dispose();
                        gizmoRing = null;
                    }
                    if (gizmoHandle) {
                        gizmoHandle.geometry.dispose();
                        gizmoHandle.material.dispose();
                        gizmoHandle = null;
                    }

                    const rugWidth = 2;
                    const aspectRatio = texture.image.height / texture.image.width;
                    const rugHeight = rugWidth * aspectRatio;

                    // Use BoxGeometry instead of PlaneGeometry to give the rug thickness/depth
                    const rugDepth = 0.01; // Add some thickness to the rug 
                    const geometry = new THREE.BoxGeometry(rugWidth, rugHeight, rugDepth);
                    const material = new THREE.MeshBasicMaterial({
                        map: texture,
                        side: THREE.DoubleSide,
                        transparent: true
                    });

                    rug = new THREE.Mesh(geometry, material);
                    rug.visible = rugParams.visible;

                    // Create 3D gizmo as child of rug
                    const smallerDim = Math.min(rugWidth, rugHeight);
                    const ringRadius = smallerDim * 0.25; // Smaller ring
                    const tubeRadius = 0.015;
                    const gizmoHeight = 0.20; // Higher above rug surface

                    // Darker steel color for visibility
                    const steelColor = 0x4a4a4a;

                    // Create ring gizmo
                    const ringGeometry = new THREE.TorusGeometry(ringRadius, tubeRadius, 8, 48);
                    const ringMaterial = new THREE.MeshBasicMaterial({
                        color: steelColor,
                        transparent: true,
                        opacity: 0.8,
                        depthTest: false,
                        depthWrite: false
                    });
                    gizmoRing = new THREE.Mesh(ringGeometry, ringMaterial);
                    gizmoRing.renderOrder = 999;
                    gizmoRing.position.set(0, 0, gizmoHeight);
                    gizmoRing.visible = false;

                    // Create diamond handle at the bottom of the ring for rotation indicator
                    const handleGeometry = new THREE.OctahedronGeometry(0.06, 0);
                    const handleMaterial = new THREE.MeshBasicMaterial({
                        color: steelColor, // Same stainless steel color
                        transparent: true,
                        opacity: 0.9,
                        depthTest: false,
                        depthWrite: false
                    });
                    gizmoHandle = new THREE.Mesh(handleGeometry, handleMaterial);
                    gizmoHandle.renderOrder = 1000;
                    gizmoHandle.position.set(0, -ringRadius, gizmoHeight); // At bottom of ring
                    gizmoHandle.scale.set(1.5, 1, 0.6); // Flatten to diamond shape
                    gizmoHandle.visible = false;

                    // Create corner resize handles (small white squares with black outline like MS Paint)
                    cornerHandles = [];
                    const cornerZ = rugDepth / 2 + 0.05; // Higher above the rug surface for visibility
                    const cornerPositions = [
                        { x: rugWidth / 2, y: rugHeight / 2 },   // Top-right
                        { x: -rugWidth / 2, y: rugHeight / 2 },  // Top-left
                        { x: -rugWidth / 2, y: -rugHeight / 2 }, // Bottom-left
                        { x: rugWidth / 2, y: -rugHeight / 2 }   // Bottom-right
                    ];

                    const handleSize = 0.08; // Larger square size for visibility
                    const outlineThickness = 0.01; // Outline thickness

                    // Black outline (slightly larger box behind)
                    const outlineGeometry = new THREE.BoxGeometry(
                        handleSize + outlineThickness * 2,
                        handleSize + outlineThickness * 2,
                        0.01
                    );
                    const outlineMaterial = new THREE.MeshBasicMaterial({
                        color: 0x000000,
                        depthTest: false,
                        depthWrite: false,
                        side: THREE.DoubleSide
                    });

                    // White fill (smaller box in front)
                    const cornerGeometry = new THREE.BoxGeometry(handleSize, handleSize, 0.01);
                    const cornerMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        depthTest: false,
                        depthWrite: false,
                        side: THREE.DoubleSide
                    });

                    cornerPositions.forEach((pos, index) => {
                        // Create a group for the corner handle
                        const cornerGroup = new THREE.Group();
                        cornerGroup.position.set(pos.x, pos.y, cornerZ);
                        cornerGroup.visible = false;
                        cornerGroup.userData.cornerIndex = index;

                        // Add black outline box
                        const outline = new THREE.Mesh(outlineGeometry, outlineMaterial.clone());
                        outline.renderOrder = 999;
                        cornerGroup.add(outline);

                        // Add white fill box (slightly in front)
                        const fill = new THREE.Mesh(cornerGeometry, cornerMaterial.clone());
                        fill.position.z = 0.006;
                        fill.renderOrder = 1000;
                        cornerGroup.add(fill);

                        cornerHandles.push(cornerGroup);
                        rug.add(cornerGroup);
                    });

                    // Add gizmo as children of rug
                    rug.add(gizmoRing);
                    rug.add(gizmoHandle);

                    if (viewer.threeScene) {
                        viewer.threeScene.add(rug);
                    }

                    resolve(rug);
                }, undefined, reject);
            });
        }

        function createFloorPlaneVisualization() {
            // Remove existing floor plane visualization
            if (floorPlaneMesh && viewer.threeScene) {
                viewer.threeScene.remove(floorPlaneMesh);
                floorPlaneMesh.geometry.dispose();
                floorPlaneMesh.material.dispose();
                floorPlaneMesh = null;
            }

            if (!detectedPlane) return;

            // Calculate bounding box of all splats to size the plane appropriately
            const splatMesh = viewer.splatMesh;
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;

            if (splatMesh) {
                const splatCount = splatMesh.getSplatCount();
                const center = new THREE.Vector3();
                const sampleStep = Math.max(1, Math.floor(splatCount / 5000)); // Sample for performance

                for (let i = 0; i < splatCount; i += sampleStep) {
                    splatMesh.getSplatCenter(i, center);
                    minX = Math.min(minX, center.x);
                    maxX = Math.max(maxX, center.x);
                    minY = Math.min(minY, center.y);
                    maxY = Math.max(maxY, center.y);
                    minZ = Math.min(minZ, center.z);
                    maxZ = Math.max(maxZ, center.z);
                }
            }

            // Calculate plane size based on scene bounds with some padding
            const sceneWidth = Math.max(20, (maxX - minX) * 1.5);
            const sceneDepth = Math.max(20, (maxZ - minZ) * 1.5);
            const planeSize = Math.max(sceneWidth, sceneDepth);
            const gridDivisions = 40;

            console.log(`Floor plane size: ${planeSize.toFixed(2)} (scene bounds: ${sceneWidth.toFixed(2)} x ${sceneDepth.toFixed(2)})`);

            // Create plane geometry
            const geometry = new THREE.PlaneGeometry(planeSize, planeSize, gridDivisions, gridDivisions);

            // Create wireframe material with low opacity
            const material = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                wireframe: true,
                transparent: true,
                opacity: 0.15,
                depthTest: true,
                side: THREE.DoubleSide
            });

            floorPlaneMesh = new THREE.Mesh(geometry, material);

            // Position the plane at the detected floor centroid
            floorPlaneMesh.position.copy(detectedPlane.centroid);

            // Orient the plane to match the detected floor normal
            const up = new THREE.Vector3(0, 0, 1);
            const quaternion = new THREE.Quaternion().setFromUnitVectors(up, detectedPlane.normal);
            floorPlaneMesh.quaternion.copy(quaternion);

            // Start hidden
            floorPlaneMesh.visible = floorPlaneVisible;

            if (viewer.threeScene) {
                viewer.threeScene.add(floorPlaneMesh);
            }
        }

        function placeRugOnFloor() {
            if (!rug || !detectedPlane) return;

            const plane = detectedPlane;

            // Get camera position and forward direction
            const cameraPos = viewer.camera.position.clone();
            const cameraDir = new THREE.Vector3();
            viewer.camera.getWorldDirection(cameraDir);

            // Detect if this is a vertical plane (wall) based on normal
            const isVerticalPlane = Math.abs(plane.normal.y) < 0.3;

            if (isVerticalPlane) {
                console.log('Placing rug on VERTICAL surface (wall)');
                placeRugOnWall(plane, cameraPos, cameraDir);
            } else {
                console.log('Placing rug on HORIZONTAL surface (floor)');
                placeRugOnHorizontalFloor(plane, cameraPos, cameraDir);
            }

            // Debug logging
            console.log('Rug placed! Properties:');
            console.log('  - Position:', rug.position);
            console.log('  - Visible:', rug.visible);
            console.log('  - Scale:', rug.scale);
            console.log('  - In scene:', viewer.threeScene.children.includes(rug));
        }

        function placeRugOnWall(plane, cameraPos, cameraDir) {
            // For vertical walls: place rug directly on the wall plane in front of camera

            // Project camera position onto the wall plane
            const wallPlane = new THREE.Plane().setFromNormalAndCoplanarPoint(plane.normal, plane.centroid);
            const distToWall = wallPlane.distanceToPoint(cameraPos);

            console.log('Wall distance from camera:', distToWall.toFixed(2));

            // Place rug at wall centroid, at a comfortable viewing height
            // In inverted coords, camera Y is typically around 0
            // We want the rug to be roughly at eye level (same Y as camera or slightly adjusted)
            let position = plane.centroid.clone();

            // Adjust Y to be at camera level (for wall-mounted items like art)
            position.y = cameraPos.y;

            // For vertical/top-down views: apply automatic Z offset of -0.15
            const autoZOffset = -0.04;
            position.z += autoZOffset;
            console.log('Applied automatic Z offset for vertical plane:', autoZOffset);

            // Apply manual X, Y, and Z offsets
            position.x += rugParams.offsetX;
            position.y += rugParams.offsetY;
            position.z += rugParams.offsetZ;

            rug.position.copy(position);

            // Orient rug to be flat against the wall
            // The rug's local Z should align with the wall normal
            const up = new THREE.Vector3(0, 0, 1);
            const quaternion = new THREE.Quaternion().setFromUnitVectors(up, plane.normal);
            rug.quaternion.copy(quaternion);

            // Apply rotation around the wall normal
            const rotationQuat = new THREE.Quaternion().setFromAxisAngle(plane.normal, rugParams.rotation * Math.PI / 180);
            rug.quaternion.premultiply(rotationQuat);

            rug.scale.set(rugParams.scale, rugParams.scale, rugParams.scale);
            rug.visible = rugParams.visible;
        }

        function placeRugOnHorizontalFloor(plane, cameraPos, cameraDir) {
            let position;

            // Check if this is a generated splat (from API) or a local splat
            if (generatedSplatData) {
                // FOR GENERATED SPLATS: Use simple placement at floor centroid
                console.log('Generated splat detected - using simple floor centroid placement');

                position = plane.centroid.clone();

                // Add small offset along floor normal to place rug slightly above the grid
                const rugHeightOffset = 0.001; // 0.1cm above the detected floor plane
                position.add(plane.normal.clone().multiplyScalar(rugHeightOffset));

                console.log('Placing rug at floor centroid:', position);
            } else {
                // FOR LOCAL SPLATS: Use complex camera-based placement
                console.log('Local splat detected - using camera-based placement');

                // Create a floor plane
                const floorPlane = new THREE.Plane();
                floorPlane.setFromNormalAndCoplanarPoint(plane.normal, plane.centroid);

                const targetDistance = 3.0;  // Fixed 3 units in front of camera
                const minDistance = 2.0;
                const maxDistance = 5.0;

                // Strategy: Place rug at a comfortable distance in front of camera
                const targetPoint = cameraPos.clone().add(cameraDir.clone().multiplyScalar(targetDistance));

                // Use the target point's X and Z, but ALWAYS use the floor centroid's Y
                position = new THREE.Vector3(targetPoint.x, plane.centroid.y, targetPoint.z);

                // Verify the position is reasonable
                const distanceFromCamera = position.distanceTo(cameraPos);

                // If too close or too far, adjust
                if (distanceFromCamera < minDistance || distanceFromCamera > maxDistance) {
                    console.log('Distance out of range:', distanceFromCamera, 'Min:', minDistance, 'Max:', maxDistance, 'Adjusting...');

                    // Fallback: project camera direction onto horizontal plane and move in that direction
                    const horizontalDir = new THREE.Vector3(cameraDir.x, 0, cameraDir.z).normalize();

                    if (horizontalDir.length() < 0.1) {
                        // Looking nearly straight up/down - use floor center
                        position = plane.centroid.clone();
                        console.log('Camera looking up/down, using floor center');
                    } else {
                        // Move from camera position in horizontal direction, but keep floor Y
                        const horizontalCameraPos = new THREE.Vector3(cameraPos.x, plane.centroid.y, cameraPos.z);
                        position = horizontalCameraPos.add(horizontalDir.multiplyScalar(targetDistance));
                        console.log('Using horizontal projection, distance:', targetDistance);
                    }
                }

                console.log('Final rug position:', position, 'Distance from camera:', position.distanceTo(cameraPos));

                // AUTO-ADJUST: If floor is way below camera, place rug at visible height
                const floorYDiff = position.y - cameraPos.y;
                if (Math.abs(floorYDiff) > 5.0) {
                    // Floor is more than 5 units away - ignore it and place at fixed height
                    const targetRugY = cameraPos.y + 1.5;
                    const autoYOffset = targetRugY - position.y;
                    console.log(`Auto-adjusting rug to Y=${targetRugY.toFixed(2)} (offset: ${autoYOffset.toFixed(2)})`);
                    rugParams.offsetY = autoYOffset;
                }
            }

            // Apply manual X, Y, and Z offsets (for both generated and local splats)
            position.x += rugParams.offsetX;
            position.y += rugParams.offsetY;
            position.z += rugParams.offsetZ;

            rug.position.copy(position);

            const up = new THREE.Vector3(0, 0, 1);
            const quaternion = new THREE.Quaternion().setFromUnitVectors(up, plane.normal);
            rug.quaternion.copy(quaternion);

            const rotationQuat = new THREE.Quaternion().setFromAxisAngle(plane.normal, rugParams.rotation * Math.PI / 180);
            rug.quaternion.premultiply(rotationQuat);

            rug.scale.set(rugParams.scale, rugParams.scale, rugParams.scale);

            rug.visible = rugParams.visible;
        }

        function updateRugPosition() {
            // Update rug position based on offset values without recalculating from camera
            if (!rug || !detectedPlane) return;

            const plane = detectedPlane;
            const position = plane.centroid.clone();

            // Apply X, Y, and Z offsets
            position.x += rugParams.offsetX;
            position.y += rugParams.offsetY;
            position.z += rugParams.offsetZ;

            rug.position.copy(position);
            updateGizmo();
        }

        function updateRug(skipPositionRecalc = false) {
            if (!skipPositionRecalc) {
                placeRugOnFloor();
            } else {
                // Just update rotation and scale without recalculating position
                if (!rug || !detectedPlane) return;

                const plane = detectedPlane;
                const up = new THREE.Vector3(0, 0, 1);
                const quaternion = new THREE.Quaternion().setFromUnitVectors(up, plane.normal);
                rug.quaternion.copy(quaternion);

                const rotationQuat = new THREE.Quaternion().setFromAxisAngle(plane.normal, rugParams.rotation * Math.PI / 180);
                rug.quaternion.premultiply(rotationQuat);

                rug.scale.set(rugParams.scale, rugParams.scale, rugParams.scale);
                rug.visible = rugParams.visible;
            }
            updateGizmo();
        }

        function updateGizmo(show = true) {
            if (!gizmoRing || !gizmoHandle || !rug || !rug.visible) {
                if (gizmoRing) gizmoRing.visible = false;
                if (gizmoHandle) gizmoHandle.visible = false;
                cornerHandles.forEach(corner => corner.visible = false);
                gizmoVisible = false;
                return;
            }

            gizmoRing.visible = show;
            gizmoHandle.visible = show;
            cornerHandles.forEach(corner => corner.visible = show);
            gizmoVisible = show;
        }


        function findGizmoIntersection(event) {
            if (!gizmoRing || !gizmoHandle || !rug) return false;

            const rect = viewer.renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, viewer.camera);
            const intersects = raycaster.intersectObjects([gizmoRing, gizmoHandle], false);
            return intersects.length > 0;
        }

        function findCornerIntersection(event) {
            if (!rug || cornerHandles.length === 0) return null;

            const rect = viewer.renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, viewer.camera);
            // Raycast into corner groups recursively to hit child meshes
            const intersects = raycaster.intersectObjects(cornerHandles, true);
            if (intersects.length > 0) {
                // Get the parent group's cornerIndex
                let obj = intersects[0].object;
                while (obj && obj.userData.cornerIndex === undefined) {
                    obj = obj.parent;
                }
                if (obj && obj.userData.cornerIndex !== undefined) {
                    return obj.userData.cornerIndex;
                }
            }
            return null;
        }

        function raycastMouseOnRug(event) {
            if (!rug) return null;

            const rect = viewer.renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, viewer.camera);
            const intersects = raycaster.intersectObject(rug);
            return intersects.length > 0 ? intersects[0] : null;
        }

        function onMouseDown(event) {
            if (!rug || !rug.visible) return;

            // Check if clicking on corner handle (for resizing)
            const cornerIndex = findCornerIntersection(event);
            if (cornerIndex !== null) {
                isResizing = true;
                isDragging = false;
                isRotating = false;
                activeCorner = cornerIndex;
                initialScale = rugParams.scale;
                initialRugCenter = rug.position.clone();

                // Get opposite corner index (0<->2, 1<->3)
                const oppositeIndex = (cornerIndex + 2) % 4;

                // Get corner world positions
                oppositeCornerWorld = new THREE.Vector3();
                cornerHandles[oppositeIndex].getWorldPosition(oppositeCornerWorld);

                draggedCornerWorld = new THREE.Vector3();
                cornerHandles[cornerIndex].getWorldPosition(draggedCornerWorld);

                // Store initial distance between corners
                initialDistance = oppositeCornerWorld.distanceTo(draggedCornerWorld);

                viewer.controls.enabled = false;
                viewer.renderer.domElement.style.cursor = 'nwse-resize';
                event.preventDefault();
                return;
            }

            // Check if clicking on gizmo (for rotation)
            if (findGizmoIntersection(event)) {
                isRotating = true;
                isDragging = false;
                isResizing = false;
                previousMouse = { x: event.clientX, y: event.clientY };
                viewer.controls.enabled = false;
                viewer.renderer.domElement.style.cursor = 'grabbing';
                event.preventDefault();
                return;
            }

            // Check if clicking on rug (for dragging)
            const intersect = raycastMouseOnRug(event);
            if (intersect) {
                isDragging = true;
                isRotating = false;
                isResizing = false;

                // Calculate offset using floor plane intersection, not rug intersection
                // This ensures consistent behavior on tilted floors
                const rect = viewer.renderer.domElement.getBoundingClientRect();
                const mouse = new THREE.Vector2();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, viewer.camera);

                // Raycast to the floor plane at the rug's position
                const floorPlane = new THREE.Plane();
                floorPlane.setFromNormalAndCoplanarPoint(detectedPlane.normal, rug.position);

                const floorPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(floorPlane, floorPoint);

                if (floorPoint) {
                    // Calculate offset from floor intersection to rug center
                    offset.copy(floorPoint).sub(rug.position);
                } else {
                    // Fallback to old method if raycast fails
                    offset.copy(intersect.point).sub(rug.position);
                }

                viewer.controls.enabled = false;
                viewer.renderer.domElement.style.cursor = 'grabbing';
                event.preventDefault();
            }
        }

        function onMouseMove(event) {
            if (!rug || !rug.visible) return;

            if (isResizing) {
                // Raycast to floor plane to find mouse position in 3D space
                const rect = viewer.renderer.domElement.getBoundingClientRect();
                const mouse = new THREE.Vector2();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, viewer.camera);

                // Create a plane at the rug's current position with the floor normal
                const floorPlane = new THREE.Plane();
                floorPlane.setFromNormalAndCoplanarPoint(detectedPlane.normal, rug.position);

                // Find intersection point on the floor plane
                const mouseWorldPos = new THREE.Vector3();
                raycaster.ray.intersectPlane(floorPlane, mouseWorldPos);

                if (mouseWorldPos) {
                    // Calculate new distance from opposite corner to mouse
                    const currentDistance = oppositeCornerWorld.distanceTo(mouseWorldPos);

                    // Calculate scale ratio
                    const scaleRatio = currentDistance / initialDistance;
                    const newScale = Math.max(0.1, Math.min(10, initialScale * scaleRatio));
                    rugParams.scale = newScale;

                    // Calculate new rug center position
                    // The center should be midway between the opposite corner and the mouse position
                    const newCenter = new THREE.Vector3().addVectors(oppositeCornerWorld, mouseWorldPos).multiplyScalar(0.5);

                    // Preserve the original Y position - don't let resizing change height
                    newCenter.y = rug.position.y;

                    // Update offset parameters to reflect the new position
                    const initialPos = detectedPlane.centroid.clone();

                    rugParams.offsetX = newCenter.x - initialPos.x;
                    // Don't update offsetY - keep rug at same height when resizing
                    rugParams.offsetZ = newCenter.z - initialPos.z;

                    // Update position directly, then apply rotation and scale without recalculating position
                    rug.position.copy(newCenter);
                    updateRug(true);

                    if (gui) {
                        gui.controllersRecursive().forEach(controller => controller.updateDisplay());
                    }
                }

                event.preventDefault();
            } else if (isRotating) {
                const deltaX = previousMouse.x - event.clientX;
                rugParams.rotation += deltaX;
                if (rugParams.rotation < 0) rugParams.rotation += 360;
                if (rugParams.rotation >= 360) rugParams.rotation -= 360;

                updateRug(true); // Skip position recalculation, only update rotation

                if (gui) {
                    gui.controllersRecursive().forEach(controller => controller.updateDisplay());
                }

                previousMouse = { x: event.clientX, y: event.clientY };
                event.preventDefault();
            } else if (isDragging) {
                // Raycast onto the floor plane instead of the rug for accurate dragging
                const rect = viewer.renderer.domElement.getBoundingClientRect();
                const mouse = new THREE.Vector2();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, viewer.camera);

                // Create a plane at the rug's current position with the floor normal
                const floorPlane = new THREE.Plane();
                floorPlane.setFromNormalAndCoplanarPoint(detectedPlane.normal, rug.position);

                // Find intersection point on the floor plane
                const mouseWorldPos = new THREE.Vector3();
                const intersected = raycaster.ray.intersectPlane(floorPlane, mouseWorldPos);

                if (intersected && mouseWorldPos) {
                    const newPos = mouseWorldPos.clone().sub(offset);

                    // Let the plane intersection handle positioning - it automatically keeps the rug
                    // on the floor whether it's horizontal, vertical, or tilted
                    // No need to fix individual coordinates - the plane constraint handles everything

                    rug.position.copy(newPos);

                    // Update the offset params to match
                    const initialPos = detectedPlane.centroid.clone();

                    rugParams.offsetX = newPos.x - initialPos.x;
                    rugParams.offsetY = newPos.y - initialPos.y;
                    rugParams.offsetZ = newPos.z - initialPos.z;

                    if (gui) {
                        gui.controllersRecursive().forEach(controller => controller.updateDisplay());
                    }

                    updateGizmo();
                    event.preventDefault();
                }
            } else {
                // Show gizmo on hover
                const cornerIndex = findCornerIntersection(event);
                if (cornerIndex !== null) {
                    updateGizmo(true);
                    viewer.renderer.domElement.style.cursor = 'nwse-resize';
                } else if (findGizmoIntersection(event)) {
                    updateGizmo(true);
                    viewer.renderer.domElement.style.cursor = 'grab';
                } else {
                    const intersect = raycastMouseOnRug(event);
                    if (intersect) {
                        updateGizmo(true);
                        viewer.renderer.domElement.style.cursor = 'move';
                    } else {
                        updateGizmo(false);
                        viewer.renderer.domElement.style.cursor = 'default';
                    }
                }
            }
        }

        function onMouseUp(event) {
            if (isDragging || isRotating || isResizing) {
                isDragging = false;
                isRotating = false;
                isResizing = false;
                activeCorner = null;
                oppositeCornerWorld = null;
                draggedCornerWorld = null;
                initialRugCenter = null;
                viewer.controls.enabled = true; // Re-enable controls after interaction
                viewer.renderer.domElement.style.cursor = 'default';
                event.preventDefault();
            }
        }

        function setupGUI() {
            if (gui) gui.destroy();

            gui = new GUI();
            gui.title('Rug Controls');

            gui.add(rugParams, 'visible').name('Visible').onChange(() => {
                if (rug) {
                    rug.visible = rugParams.visible;
                    updateGizmo(rugParams.visible);
                }
            });

            const posFolder = gui.addFolder('Position Offset');
            posFolder.add(rugParams, 'offsetX', -3, 3, 0.01).name('X').onChange(() => updateRugPosition());
            posFolder.add(rugParams, 'offsetY', -0.5, 0.5, 0.001).name('Y').onChange(() => updateRugPosition());
            posFolder.add(rugParams, 'offsetZ', -3, 3, 0.01).name('Z').onChange(() => updateRugPosition());
            posFolder.open();

            const transformFolder = gui.addFolder('Transform');
            transformFolder.add(rugParams, 'rotation', 0, 360, 1).name('Rotation (°)').onChange(() => updateRug(true));
            transformFolder.add(rugParams, 'scale', 0.1, 10, 0.01).name('Scale').onChange(() => updateRug(true));
            transformFolder.open();
        }

        /**
         * Fit a plane to floor gaussians using PCA (Principal Component Analysis)
         * This finds the best-fit plane at any orientation based on the actual floor gaussian positions
         */
        function fitPlaneToFloorGaussians(floorPositions) {
            const n = floorPositions.length;
            if (n < 3) return null;

            // Calculate centroid
            let sumX = 0, sumY = 0, sumZ = 0;
            for (const pos of floorPositions) {
                sumX += pos.x;
                sumY += pos.y;
                sumZ += pos.z;
            }
            const centroid = new THREE.Vector3(sumX / n, sumY / n, sumZ / n);

            // Build covariance matrix (centered around centroid)
            let xx = 0, xy = 0, xz = 0;
            let yy = 0, yz = 0, zz = 0;

            for (const pos of floorPositions) {
                const dx = pos.x - centroid.x;
                const dy = pos.y - centroid.y;
                const dz = pos.z - centroid.z;

                xx += dx * dx;
                xy += dx * dy;
                xz += dx * dz;
                yy += dy * dy;
                yz += dy * dz;
                zz += dz * dz;
            }

            // Normalize by n
            xx /= n; xy /= n; xz /= n;
            yy /= n; yz /= n; zz /= n;

            // Use simplified SVD approach: the normal is perpendicular to the plane of maximum variance
            // We find two orthogonal directions in the plane and cross them to get the normal

            // Find the direction of maximum variance (first principal component)
            let pc1 = new THREE.Vector3(1, 0, 0);
            for (let iter = 0; iter < 20; iter++) {
                const x = xx * pc1.x + xy * pc1.y + xz * pc1.z;
                const y = xy * pc1.x + yy * pc1.y + yz * pc1.z;
                const z = xz * pc1.x + yz * pc1.y + zz * pc1.z;
                pc1.set(x, y, z).normalize();
            }

            // Find the second principal component (orthogonal to first)
            let pc2 = new THREE.Vector3(0, 1, 0);
            // Make it orthogonal to pc1
            pc2.sub(pc1.clone().multiplyScalar(pc2.dot(pc1))).normalize();

            // Refine pc2
            for (let iter = 0; iter < 20; iter++) {
                const x = xx * pc2.x + xy * pc2.y + xz * pc2.z;
                const y = xy * pc2.x + yy * pc2.y + yz * pc2.z;
                const z = xz * pc2.x + yz * pc2.y + zz * pc2.z;
                pc2.set(x, y, z);
                // Re-orthogonalize against pc1
                pc2.sub(pc1.clone().multiplyScalar(pc2.dot(pc1))).normalize();
            }

            // The normal is perpendicular to both principal components
            const normal = new THREE.Vector3().crossVectors(pc1, pc2).normalize();

            // Orient normal to point toward camera (away from the floor surface)
            const cameraPos = viewer.camera.position;
            const cameraUp = viewer.camera.up;
            const centroidToCamera = new THREE.Vector3().subVectors(cameraPos, centroid);

            // Check for inverted coordinate system
            const isInvertedY = cameraUp.y < 0;
            console.log('Camera coordinate system:', isInvertedY ? 'INVERTED (up=-Y)' : 'NORMAL (up=+Y)');

            // If normal points away from camera, flip it
            if (normal.dot(centroidToCamera) < 0) {
                normal.negate();
            }

            // For inverted Y systems, verify the normal orientation makes sense
            if (isInvertedY) {
                // In inverted systems, floor normal should generally point in +Y direction (up in inverted coords)
                // But we already oriented it toward camera, so this should be correct
                console.log('Inverted Y detected - normal already oriented toward camera');
            }

            // Calculate d for plane equation ax + by + cz + d = 0
            const d = -normal.dot(centroid);

            console.log('Fitted plane to', n, 'floor gaussians using PCA');
            console.log('Plane normal:', normal.toArray().map(v => v.toFixed(3)));
            console.log('Plane centroid:', centroid.toArray().map(v => v.toFixed(3)));
            console.log('Camera position:', cameraPos.toArray().map(v => v.toFixed(3)));

            return {
                normal: normal,
                centroid: centroid,
                d: d,
                inliers: n
            };
        }

        async function detectFloor() {
            const status = document.getElementById('status');

            status.style.display = 'block';
            status.textContent = 'Detecting floor...';

            await new Promise(resolve => requestAnimationFrame(resolve));

            try {
                const splatMesh = viewer.splatMesh;
                if (!splatMesh) throw new Error('Splat mesh not loaded');

                const splatCount = splatMesh.getSplatCount();

                // FOR GENERATED SPLATS: Use floor mask directly
                if (floorMaskData && Array.isArray(floorMaskData)) {
                    console.log('=== USING FLOOR MASK FOR DETECTION ===');
                    status.textContent = 'Using API floor mask...';

                    // Collect positions of all floor gaussians
                    const floorPositions = [];
                    const center = new THREE.Vector3();

                    for (let i = 0; i < Math.min(floorMaskData.length, splatCount); i++) {
                        if (floorMaskData[i]) { // Floor gaussian
                            splatMesh.getSplatCenter(i, center);
                            floorPositions.push(center.clone());
                        }
                    }

                    console.log('Floor gaussians from mask:', floorPositions.length);

                    if (floorPositions.length < 10) {
                        status.textContent = 'Not enough floor gaussians detected!';
                        return false;
                    }

                    // Fit plane to floor gaussians using least squares
                    const plane = fitPlaneToFloorGaussians(floorPositions);

                    if (plane) {
                        // Apply small offset above the floor (0.02 units toward camera)
                        const smallOffset = 0.015;
                        plane.centroid.add(plane.normal.clone().multiplyScalar(smallOffset));
                        plane.d = -plane.normal.dot(plane.centroid);

                        console.log(`Floor offset: ${smallOffset.toFixed(3)}m above surface`);
                        console.log(`Final floor centroid:`, plane.centroid);
                        console.log(`Floor normal:`, plane.normal);

                        detectedPlane = plane;
                        // Don't show the green grid visualization by default
                        createFloorPlaneVisualization();
                        floorPlaneVisible = false;
                        if (floorPlaneMesh) {
                            floorPlaneMesh.visible = false;
                        }

                        status.innerHTML = `<strong>Floor Detected (from mask)!</strong><br>
                            Floor gaussians: ${floorPositions.length}<br>
                            Plane fitted to top surface<br>
                            Ready to place rug!`;
                        return true;
                    } else {
                        status.textContent = 'Failed to fit plane to floor gaussians';
                        return false;
                    }
                }

                // FOR LOCAL SPLATS: Use RANSAC with orientation
                console.log('=== USING RANSAC FOR LOCAL SPLAT ===');

                // Get user-selected view type from radio buttons
                const viewType = document.querySelector('input[name="viewType"]:checked').value;
                floorOrientation = viewType === 'top' ? 'vertical' : 'horizontal';
                console.log('Floor detection using view type:', viewType, '→ orientation:', floorOrientation);

                const targetSampleCount = 20000;
                const step = Math.max(1, Math.floor(splatCount / targetSampleCount));

                const points = [];
                const center = new THREE.Vector3();

                for (let i = 0; i < splatCount; i += step) {
                    splatMesh.getSplatCenter(i, center);
                    points.push({ x: center.x, y: center.y, z: center.z });
                }

                status.textContent = `Analyzing ${points.length.toLocaleString()} points...`;

                await new Promise(resolve => setTimeout(resolve, 10));

                // Use the detected floor orientation (from API mask analysis)
                const plane = ransacPlaneDetection(points, 2000, 0.05, floorOrientation);

                if (plane) {
                    // MONOCULAR SPLAT FIX: Use adaptive offset based on point distribution
                    const upwardOffset = plane.adaptiveOffset || 0.035;
                    plane.centroid.add(plane.normal.clone().multiplyScalar(upwardOffset));

                    console.log(`Applied adaptive floor offset: ${upwardOffset.toFixed(3)}m`);
                    console.log(`Floor plane centroid:`, plane.centroid);
                    console.log(`Floor plane normal:`, plane.normal);
                    console.log(`Camera position:`, viewer.camera.position);

                    detectedPlane = plane;
                    // Don't show the green grid visualization by default
                    createFloorPlaneVisualization();
                    floorPlaneVisible = false;
                    if (floorPlaneMesh) {
                        floorPlaneMesh.visible = false;
                    }

                    status.innerHTML = `<strong>Floor Detected (RANSAC)!</strong><br>
                        Height: ${plane.centroid.y.toFixed(2)}<br>
                        Offset: ${upwardOffset.toFixed(3)}m<br>
                        Camera Y: ${viewer.camera.position.y.toFixed(2)}<br>
                        Ready to place rug!`;
                    return true;
                } else {
                    status.textContent = 'Could not find floor. Please try again.';
                    return false;
                }
            } catch (error) {
                status.textContent = `Error: ${error.message}`;
                console.error(error);
                return false;
            }
        }

        async function handleRugUpload(event) {
            const file = event.target.files[0];
            const status = document.getElementById('status');

            if (file) {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    customRugTexture = e.target.result;
                    status.textContent = 'Custom rug loaded! Placing on floor...';
                    status.style.display = 'block';

                    // Reset the rug select dropdown
                    const rugSelect = document.getElementById('rugSelect');
                    if (rugSelect) rugSelect.value = '';

                    // Automatically place the custom rug
                    await placeRugAuto(customRugTexture);
                };
                reader.readAsDataURL(file);
            }
        }

        function removeCurrentRug() {
            // Remove rug if exists
            if (rug && viewer.threeScene) {
                viewer.threeScene.remove(rug);
                if (rug.geometry) rug.geometry.dispose();
                if (rug.material) {
                    if (rug.material.map) rug.material.map.dispose();
                    rug.material.dispose();
                }
                rug = null;
            }

            // Destroy GUI if exists
            if (gui) {
                gui.destroy();
                gui = null;
            }

            // Clear gizmo
            if (gizmoRing) {
                gizmoRing.geometry.dispose();
                gizmoRing.material.dispose();
                gizmoRing = null;
            }
            if (gizmoHandle) {
                gizmoHandle.geometry.dispose();
                gizmoHandle.material.dispose();
                gizmoHandle = null;
            }
            // Clear corner handles
            cornerHandles.forEach(cornerGroup => {
                cornerGroup.children.forEach(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
            });
            cornerHandles = [];
            gizmoVisible = false;
        }

        async function placeRugAuto(rugTextureUrl) {
            const status = document.getElementById('status');

            // Check if camera has moved significantly since last rug placement
            const currentCameraPos = viewer.camera.position.clone();
            let cameraMoved = false;

            if (lastCameraPosition) {
                const distance = currentCameraPos.distanceTo(lastCameraPosition);
                cameraMoved = distance > cameraMovementThreshold;
                console.log('Camera movement distance:', distance, 'Threshold:', cameraMovementThreshold, 'Moved:', cameraMoved);
            }

            // Save current rug's actual world position before removing (not offsets!)
            // Only save if camera hasn't moved significantly
            const savedPosition = (rug && !cameraMoved) ? rug.position.clone() : null;
            const savedParams = (rug && !cameraMoved) ? {
                rotation: rugParams.rotation,
                scale: rugParams.scale
            } : null;

            // Remove old rug if exists
            removeCurrentRug();

            status.textContent = 'Detecting floor...';
            status.style.display = 'block';

            try {
                // First detect the floor (only if not already detected)
                if (!detectedPlane) {
                    const floorDetected = await detectFloor();
                    if (!floorDetected) {
                        return;
                    }
                }

                // Then create and place the rug
                status.textContent = 'Placing rug...';
                await createRug(rugTextureUrl);

                // Restore saved parameters if replacing an existing rug AND camera hasn't moved
                if (savedPosition && savedParams) {
                    // Place rug at exact same world position
                    rug.position.copy(savedPosition);

                    // Calculate offsets relative to floor centroid
                    const plane = detectedPlane;
                    const basePosition = plane.centroid.clone();

                    rugParams.offsetX = savedPosition.x - basePosition.x;
                    rugParams.offsetY = savedPosition.y - basePosition.y;
                    rugParams.offsetZ = savedPosition.z - basePosition.z;
                    rugParams.rotation = savedParams.rotation;
                    rugParams.scale = savedParams.scale;

                    // Apply rotation and orientation
                    const up = new THREE.Vector3(0, 0, 1);
                    const quaternion = new THREE.Quaternion().setFromUnitVectors(up, plane.normal);
                    rug.quaternion.copy(quaternion);

                    const rotationQuat = new THREE.Quaternion().setFromAxisAngle(plane.normal, rugParams.rotation * Math.PI / 180);
                    rug.quaternion.premultiply(rotationQuat);

                    rug.scale.set(rugParams.scale, rugParams.scale, rugParams.scale);
                    rug.visible = rugParams.visible;

                    console.log('Rug replaced at saved position:', savedPosition);
                } else {
                    // First rug OR camera moved - place based on current camera position
                    // Reset offsets since we're calculating a fresh position
                    rugParams.offsetX = 0;
                    rugParams.offsetY = 0;
                    rugParams.offsetZ = 0;

                    placeRugOnFloor();

                    // Save current camera position
                    lastCameraPosition = currentCameraPos;
                    console.log('Rug placed at new position based on camera. Camera position saved:', lastCameraPosition);
                }

                setupGUI();
                updateGizmo();
                status.textContent = 'Rug placed! Use controls on the right to adjust. Hover over rug to see gizmo. Hover over the corners for resizing.';
            } catch (error) {
                status.textContent = `Error: ${error.message}`;
            }
        }

        async function handleRugSelect(event) {
            const rugPath = event.target.value;
            if (rugPath) {
                await placeRugAuto(rugPath);
            }
        }

        function cleanupScene() {
            // Remove current rug and its gizmos
            removeCurrentRug();

            // Remove floor plane visualization
            if (floorPlaneMesh && viewer.threeScene) {
                viewer.threeScene.remove(floorPlaneMesh);
                floorPlaneMesh.geometry.dispose();
                floorPlaneMesh.material.dispose();
                floorPlaneMesh = null;
            }
            floorPlaneVisible = false;

            // Clear detected plane
            detectedPlane = null;

            // Clear custom rug texture
            customRugTexture = null;

            // Reset rug params
            rugParams.visible = true;
            rugParams.offsetX = 0;
            rugParams.offsetY = 0.0; // Small offset to place rug above the floor visualization grid
            rugParams.offsetZ = 0;
            rugParams.rotation = 0;
            rugParams.scale = 0.5;

            // Reset file input
            const rugInput = document.getElementById('rugImageInput');
            if (rugInput) rugInput.value = '';

            // Reset rug select dropdown
            const rugSelect = document.getElementById('rugSelect');
            if (rugSelect) rugSelect.value = '';
        }

        async function changeSplat(newSplatPath) {
            const status = document.getElementById('status');
            status.style.display = 'block';
            status.textContent = 'Loading new scene...';

            try {
                // Cleanup old scene
                cleanupScene();

                // Remove old splat scene
                if (viewer.splatMesh) {
                    await viewer.removeSplatScene(0);
                }

                splatLoaded = false;
                currentSplatPath = newSplatPath;

                // Load new splat scene
                await viewer.addSplatScene(newSplatPath, {
                    progressiveLoad: true
                });

                viewer.start();
                splatLoaded = true;
                document.getElementById('toggleFloorBtn').disabled = false;
                status.textContent = 'Scene loaded! Select a sample rug or upload your own rug image.';
            } catch (error) {
                console.error('Error loading splat:', error);
                status.textContent = `Error loading scene: ${error.message}`;
            }
        }

        function handleSplatChange(event) {
            const newSplatPath = event.target.value;
            if (newSplatPath !== currentSplatPath) {
                changeSplat(newSplatPath);
            }
        }

        // Toggle controls visibility with 'H' key
        let controlsVisible = true;
        function toggleControls() {
            controlsVisible = !controlsVisible;
            const controls = document.getElementById('controls');
            const instructions = document.getElementById('instructions');

            if (controlsVisible) {
                controls.style.display = 'flex';
                if (gui) gui.show();
                instructions.style.display = 'block';
            } else {
                controls.style.display = 'none';
                if (gui) gui.hide();
                instructions.style.display = 'block'; // Keep instructions visible
            }
        }

        // Keyboard event listener
        window.addEventListener('keydown', (event) => {
            if (event.key === 'h' || event.key === 'H') {
                toggleControls();
            }
        });


        // No longer need canvas for gizmo - using 3D meshes now

        window.addEventListener('resize', () => {
            // Gizmo updates automatically with 3D transforms
        });

        viewer = new GaussianSplats3D.Viewer({
            cameraUp: [0, -1, 0],  // Inverted up direction for monocular splat
            initialCameraPosition: [0, 0, 3],  // Position in front, looking at origin
            initialCameraLookAt: [0, 0, 0],  // Look at center
            sphericalHarmonicsDegree: 2,
            sharedMemoryForWorkers: false,
            selfDrivenMode: true
        });

        // Camera controls are ENABLED for free movement
        if (viewer.controls) {
            viewer.controls.enabled = true;
            // Enable mouse controls
            viewer.controls.enableRotate = true;
            viewer.controls.enableZoom = true;
            viewer.controls.enablePan = true;
        }

        // Prevent context menu on right-click
        viewer.renderer.domElement.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });



        document.getElementById('rugSelect').addEventListener('change', handleRugSelect);
        document.getElementById('rugImageInput').addEventListener('change', handleRugUpload);
        document.getElementById('splatSelect').addEventListener('change', handleSplatChange);

        // Generate splat event listeners
        document.getElementById('generateSplatInput').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                selectedImageFile = file;
                document.getElementById('generateSplatBtn').disabled = false;
                console.log('Image selected:', file.name);
            } else {
                selectedImageFile = null;
                document.getElementById('generateSplatBtn').disabled = true;
            }
        });

        document.getElementById('generateSplatBtn').addEventListener('click', async () => {
            if (selectedImageFile) {
                await generateSplatFromImage(selectedImageFile);
            }
        });

        document.getElementById('downloadPlyBtn').addEventListener('click', () => {
            downloadGeneratedPLY();
        });

        // Floor detection toggle button
        const toggleFloorBtn = document.getElementById('toggleFloorBtn');
        let floorVisualizationMesh = null;
        let showingFloor = false;

        toggleFloorBtn.addEventListener('click', () => {
            if (!splatLoaded || !viewer.splatMesh) {
                alert('Please load a splat scene first!');
                return;
            }

            showingFloor = !showingFloor;

            if (showingFloor) {
                // Check if we have floor mask data from API (for generated splats)
                if (floorMaskData && Array.isArray(floorMaskData)) {
                    try {
                        // Floor mask is a boolean array (true/false for each Gaussian)
                        const splatCount = viewer.splatMesh.getSplatCount();
                        console.log('Floor mask 3D size:', floorMaskData.length, 'Splat count:', splatCount);

                        // Count floor splats and collect their positions
                        let floorSplatCount = 0;
                        const floorPositions = [];
                        const center = new THREE.Vector3();

                        for (let i = 0; i < Math.min(floorMaskData.length, splatCount); i++) {
                            if (floorMaskData[i]) { // Boolean value: true = floor
                                viewer.splatMesh.getSplatCenter(i, center);
                                floorPositions.push(center.clone());
                                floorSplatCount++;
                            }
                        }

                        console.log('Floor splats detected by API:', floorSplatCount, '/', splatCount,
                            '(' + ((floorSplatCount / splatCount) * 100).toFixed(1) + '%)');

                        if (floorSplatCount > 0) {
                            // Create point cloud visualization of floor splats
                            const geometry = new THREE.BufferGeometry();
                            const positions = new Float32Array(floorSplatCount * 3);

                            for (let i = 0; i < floorSplatCount; i++) {
                                positions[i * 3] = floorPositions[i].x;
                                positions[i * 3 + 1] = floorPositions[i].y;
                                positions[i * 3 + 2] = floorPositions[i].z;
                            }

                            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                            const material = new THREE.PointsMaterial({
                                color: 0x00ff00,
                                size: 0.05,
                                sizeAttenuation: true,
                                transparent: true,
                                opacity: 0.8
                            });

                            floorVisualizationMesh = new THREE.Points(geometry, material);
                            viewer.threeScene.add(floorVisualizationMesh);

                            toggleFloorBtn.textContent = 'Hide Floor Gaussians';
                            toggleFloorBtn.classList.add('active');

                            console.log('✓ Displaying', floorSplatCount, 'floor gaussian splats from API');
                        } else {
                            alert('No floor splats detected in API response! All mask values are false.');
                            showingFloor = false;
                        }
                    } catch (error) {
                        console.error('Error visualizing floor mask:', error);
                        alert('Error displaying floor mask: ' + error.message);
                        showingFloor = false;
                    }
                } else {
                    // Fallback: Use plane detection for non-generated splats
                    const floorData = detectFloor(viewer.splatMesh);

                    if (floorData && floorData.plane) {
                        // Create a large plane mesh to visualize the detected floor
                        const planeGeometry = new THREE.PlaneGeometry(20, 20);
                        const planeMaterial = new THREE.MeshBasicMaterial({
                            color: 0x00ff00,
                            transparent: true,
                            opacity: 0.3,
                            side: THREE.DoubleSide,
                            wireframe: false
                        });

                        floorVisualizationMesh = new THREE.Mesh(planeGeometry, planeMaterial);

                        // Position the plane at the detected floor
                        const plane = floorData.plane;
                        const normal = new THREE.Vector3(plane.a, plane.b, plane.c).normalize();
                        const distance = -plane.d;

                        // Position plane at a point on the plane
                        floorVisualizationMesh.position.copy(normal.multiplyScalar(distance));

                        // Orient plane to match floor normal
                        const up = new THREE.Vector3(0, 1, 0);
                        const quaternion = new THREE.Quaternion().setFromUnitVectors(up, normal);
                        floorVisualizationMesh.quaternion.copy(quaternion);

                        // Add to scene
                        viewer.threeScene.add(floorVisualizationMesh);

                        toggleFloorBtn.textContent = 'Hide Floor Detection';
                        toggleFloorBtn.classList.add('active');

                        console.log('Floor plane equation:', plane);
                        console.log('Floor normal:', normal);
                        console.log('Floor distance from origin:', distance);
                    } else {
                        alert('Could not detect floor plane!');
                        showingFloor = false;
                    }
                }
            } else {
                // Hide floor visualization
                if (floorVisualizationMesh) {
                    viewer.threeScene.remove(floorVisualizationMesh);
                    if (floorVisualizationMesh.geometry) floorVisualizationMesh.geometry.dispose();
                    if (floorVisualizationMesh.material) floorVisualizationMesh.material.dispose();
                    floorVisualizationMesh = null;
                }
                toggleFloorBtn.textContent = (floorMaskData && Array.isArray(floorMaskData)) ? 'Show Floor Gaussians' : 'Show Floor Detection';
                toggleFloorBtn.classList.remove('active');
            }
        });

        // Load initial splat scene
        const status = document.getElementById('status');
        status.style.display = 'block';
        status.textContent = 'Loading scene...';

        function computeOptimalCameraPosition(splatMesh) {
            const splatCount = splatMesh.getSplatCount();
            const voxelSize = 0.3; // Adjust based on room size
            const voxelMap = new Map();
            const center = new THREE.Vector3();

            // 1. Voxelize splat positions
            for (let i = 0; i < splatCount; i++) {
                splatMesh.getSplatCenter(i, center);
                const voxelKey = `${Math.floor(center.x / voxelSize)},${Math.floor(center.y / voxelSize)},${Math.floor(center.z / voxelSize)}`;
                voxelMap.set(voxelKey, (voxelMap.get(voxelKey) || 0) + 1);
            }

            // 2. Find bounding box of dense region
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;
            const densityThreshold = 10; // Minimum splats per voxel to consider "dense"

            for (const [key, count] of voxelMap.entries()) {
                if (count >= densityThreshold) {
                    const [x, y, z] = key.split(',').map(Number);
                    minX = Math.min(minX, x); maxX = Math.max(maxX, x);
                    minY = Math.min(minY, y); maxY = Math.max(maxY, y);
                    minZ = Math.min(minZ, z); maxZ = Math.max(maxZ, z);
                }
            }

            // 3. Find free space within dense region
            const candidates = [];
            for (let x = minX; x <= maxX; x++) {
                for (let y = minY; y <= maxY; y++) {
                    for (let z = minZ; z <= maxZ; z++) {
                        const key = `${x},${y},${z}`;
                        const count = voxelMap.get(key) || 0;

                        // Good candidate: low immediate density but surrounded by dense voxels
                        if (count < 5) {
                            let neighborDensity = 0;
                            for (let dx = -2; dx <= 2; dx++) {
                                for (let dy = -2; dy <= 2; dy++) {
                                    for (let dz = -2; dz <= 2; dz++) {
                                        if (dx === 0 && dy === 0 && dz === 0) continue;
                                        const nKey = `${x + dx},${y + dy},${z + dz}`;
                                        neighborDensity += (voxelMap.get(nKey) || 0);
                                    }
                                }
                            }

                            if (neighborDensity > 200) { // Surrounded by walls/objects
                                candidates.push({
                                    pos: new THREE.Vector3(
                                        (x + 0.5) * voxelSize,
                                        (y + 0.5) * voxelSize,
                                        (z + 0.5) * voxelSize
                                    ),
                                    score: neighborDensity
                                });
                            }
                        }
                    }
                }
            }

            // 4. Pick best candidate (highest neighbor density)
            if (candidates.length > 0) {
                candidates.sort((a, b) => b.score - a.score);
                const best = candidates[0].pos;

                // Calculate look-at point (center of dense region)
                const lookAt = new THREE.Vector3(
                    ((minX + maxX) / 2) * voxelSize,
                    ((minY + maxY) / 2) * voxelSize,
                    ((minZ + maxZ) / 2) * voxelSize
                );

                return { position: best, lookAt: lookAt };
            }

            return null;
        }


        viewer.addSplatScene(currentSplatPath, {
            progressiveLoad: true
        })
            .then(() => {
                // For monocular splat: Calculate bounding box center and position camera in front
                const splatMesh = viewer.splatMesh;
                const splatCount = splatMesh.getSplatCount();
                const center = new THREE.Vector3();
                const boundingBox = new THREE.Box3();

                console.log('=== SPLAT DEBUG INFO ===');
                console.log('Splat count:', splatCount);

                // Calculate bounding box of the splat
                for (let i = 0; i < splatCount; i++) {
                    splatMesh.getSplatCenter(i, center);
                    boundingBox.expandByPoint(center);
                }

                const splatCenter = new THREE.Vector3();
                boundingBox.getCenter(splatCenter);
                const size = new THREE.Vector3();
                boundingBox.getSize(size);

                console.log('Bounding box MIN:', {
                    x: boundingBox.min.x,
                    y: boundingBox.min.y,
                    z: boundingBox.min.z
                });
                console.log('Bounding box MAX:', {
                    x: boundingBox.max.x,
                    y: boundingBox.max.y,
                    z: boundingBox.max.z
                });
                console.log('Splat center:', {
                    x: splatCenter.x,
                    y: splatCenter.y,
                    z: splatCenter.z
                });
                console.log('Splat size:', {
                    x: size.x,
                    y: size.y,
                    z: size.z
                });

                // Position camera in front of the splat to fill screen
                // Calculate distance based on FOV to properly frame the splat
                const fov = viewer.camera.fov || 75; // Default FOV
                const maxDim = Math.max(size.x, size.y);

                console.log('Camera FOV:', fov);
                console.log('Max dimension (x or y):', maxDim);

                // Use optimal camera position found through testing
                // This position provides the best view for the monocular splat
                const cameraPosition = new THREE.Vector3(-0.24324, -0.08784, 0.72614);
                const lookAtPoint = new THREE.Vector3(-0.24324, -0.08784, 4.05811);

                console.log('Using optimal camera position (hardcoded)');
                console.log('Camera distance from lookAt:', cameraPosition.distanceTo(lookAtPoint));

                console.log('Final camera position:', {
                    x: cameraPosition.x,
                    y: cameraPosition.y,
                    z: cameraPosition.z
                });
                console.log('Looking at point:', {
                    x: lookAtPoint.x,
                    y: lookAtPoint.y,
                    z: lookAtPoint.z
                });
                console.log('Distance from camera to lookAt:', cameraPosition.distanceTo(lookAtPoint));

                viewer.camera.position.copy(cameraPosition);
                viewer.camera.lookAt(lookAtPoint);
                viewer.controls.target.copy(lookAtPoint);
                viewer.controls.update();

                console.log('Camera up vector:', {
                    x: viewer.camera.up.x,
                    y: viewer.camera.up.y,
                    z: viewer.camera.up.z
                });
                console.log('=== END DEBUG INFO ===');

                viewer.start();

                // Camera controls are now ENABLED for free movement
                viewer.controls.enabled = true;
                viewer.controls.enableZoom = true;
                viewer.controls.enableRotate = true;
                viewer.controls.enablePan = true;

                splatLoaded = true;
                document.getElementById('toggleFloorBtn').disabled = false;
                status.textContent = 'Scene loaded! Select a sample rug or upload your own rug image.';

                const canvas = viewer.renderer.domElement;

                // Add rug interaction listeners
                canvas.addEventListener('mousedown', onMouseDown, false);
                canvas.addEventListener('mousemove', onMouseMove, false);
                canvas.addEventListener('mouseup', onMouseUp, false);
            })
            .catch(error => {
                console.error('Error loading splat:', error);
                status.textContent = `Error loading scene: ${error.message}`;
            });
    </script>
</body>

</html>